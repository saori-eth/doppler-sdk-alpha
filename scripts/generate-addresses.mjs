#!/usr/bin/env node

import { readFile, writeFile, mkdir } from 'node:fs/promises'
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'

/**
 * Simple CLI to convert a Doppler Deployments.json into a TypeScript module.
 *
 * Usage:
 *   node scripts/generate-addresses.mjs --source ../../doppler/Deployments.json --out src/generated/dopplerDeployments.ts
 *
 * Flags:
 *   --source <path|url>   Path to Deployments.json (local path preferred in mono-repo)
 *   --out <path>          Output TS file path (default: src/generated/dopplerDeployments.ts)
 */

function parseArgs(argv) {
  const args = {}
  for (let i = 0; i < argv.length; i++) {
    const key = argv[i]
    if (key === '--source') {
      args.source = argv[++i]
    } else if (key === '--out') {
      args.out = argv[++i]
    }
  }
  return args
}

function sortKeysDeep(value) {
  // Returns a new object with keys sorted recursively for stable output
  if (Array.isArray(value)) {
    return value.map((v) => sortKeysDeep(v))
  }
  if (value && typeof value === 'object') {
    const result = {}
    const keys = Object.keys(value).sort((a, b) => {
      // If both keys are numeric strings, sort numerically
      const an = Number(a)
      const bn = Number(b)
      const aIsNum = Number.isFinite(an) && String(an) === a
      const bIsNum = Number.isFinite(bn) && String(bn) === b
      if (aIsNum && bIsNum) return an - bn
      return a.localeCompare(b)
    })
    for (const k of keys) result[k] = sortKeysDeep(value[k])
    return result
  }
  return value
}

function lowerAddressesOnly(value) {
  if (Array.isArray(value)) return value.map((v) => lowerAddressesOnly(v))
  if (value && typeof value === 'object') {
    const out = {}
    for (const [k, v] of Object.entries(value)) {
      out[k] = lowerAddressesOnly(v)
    }
    return out
  }
  if (typeof value === 'string' && /^0x[0-9a-fA-F]{40}$/.test(value)) return value.toLowerCase()
  return value
}

async function readJsonFromFile(path) {
  const data = await readFile(path, 'utf8')
  return JSON.parse(data)
}

async function main() {
  const __filename = fileURLToPath(import.meta.url)
  const __dirname = dirname(__filename)

  const argv = process.argv.slice(2)
  const { source, out } = parseArgs(argv)

  const outputPath = resolve(process.cwd(), out || 'src/deployments.generated.ts')

  // Prefer explicit source; otherwise try monorepo default path
  const sourcePath = source
    ? resolve(process.cwd(), source)
    : resolve(process.cwd(), '../../doppler/Deployments.json')

  try {
    const deployments = await readJsonFromFile(sourcePath)

    const banner = `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate-addresses.mjs
// Source: ${source || '../../doppler/Deployments.json'}
// Timestamp: ${new Date().toISOString()}
// WARNING: This file is an internal build artifact and is NOT part of the public API.
// WARNING: Do NOT import from this file directly. It should not appear in IDE IntelliSense/suggestions.
// WARNING: If you need Doppler addresses, import from @addresses.ts instead (e.g. use ADDRESSES / getAddresses).
`

    const sorted = sortKeysDeep(lowerAddressesOnly(deployments))
    const tsBody = `export type GeneratedDopplerDeployments = Record<string, Record<string, string>>\n\nexport const GENERATED_DOPPLER_DEPLOYMENTS = ${JSON.stringify(
      sorted,
      null,
      2
    )} as const\n`

    const fileContents = `${banner}\n${tsBody}`

    await mkdir(dirname(outputPath), { recursive: true })
    await writeFile(outputPath, fileContents, 'utf8')

    console.log(`Wrote ${outputPath}`)
  } catch (err) {
    console.error('Failed to generate addresses TS from Deployments.json')
    console.error(err?.message || err)
    process.exitCode = 1
  }
}

main()


